{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { createContext, useMemo, useState, useEffect, useCallback, useContext } from \"react\";\nimport { flattenConnection } from \"./flatten-connection.mjs\";\nconst ProductOptionsContext = createContext(null);\nfunction ProductProvider(_ref) {\n  let {\n    children,\n    data: product,\n    initialVariantId: explicitVariantId\n  } = _ref;\n  const variants = useMemo(() => flattenConnection(product.variants ?? {}), [product.variants]);\n  if (!isProductVariantArray(variants)) {\n    throw new Error(`<ProductProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`);\n  }\n  const options = useMemo(() => getOptions(variants), [variants]);\n  const [selectedVariant, setSelectedVariant] = useState(() => getVariantBasedOnIdProp(explicitVariantId, variants));\n  const [selectedOptions, setSelectedOptions] = useState(() => getSelectedOptions(selectedVariant));\n  useEffect(() => {\n    const newSelectedVariant = getVariantBasedOnIdProp(explicitVariantId, variants);\n    setSelectedVariant(newSelectedVariant);\n    setSelectedOptions(getSelectedOptions(newSelectedVariant));\n  }, [explicitVariantId, variants]);\n  const setSelectedOption = useCallback((name, value2) => {\n    setSelectedOptions(selectedOptions2 => {\n      const opts = {\n        ...selectedOptions2,\n        [name]: value2\n      };\n      setSelectedVariant(getSelectedVariant(variants, opts));\n      return opts;\n    });\n  }, [setSelectedOptions, variants]);\n  const isOptionInStock = useCallback((option, value2) => {\n    const proposedVariant = getSelectedVariant(variants, {\n      ...selectedOptions,\n      ...{\n        [option]: value2\n      }\n    });\n    return (proposedVariant == null ? void 0 : proposedVariant.availableForSale) ?? true;\n  }, [selectedOptions, variants]);\n  const sellingPlanGroups = useMemo(() => flattenConnection(product.sellingPlanGroups ?? {}).map(sellingPlanGroup => ({\n    ...sellingPlanGroup,\n    sellingPlans: flattenConnection((sellingPlanGroup == null ? void 0 : sellingPlanGroup.sellingPlans) ?? {})\n  })), [product.sellingPlanGroups]);\n  const [selectedSellingPlan, setSelectedSellingPlan] = useState(void 0);\n  const selectedSellingPlanAllocation = useMemo(() => {\n    var _a, _b;\n    if (!selectedVariant || !selectedSellingPlan) {\n      return;\n    }\n    if (!((_a = selectedVariant.sellingPlanAllocations) == null ? void 0 : _a.nodes) && !((_b = selectedVariant.sellingPlanAllocations) == null ? void 0 : _b.edges)) {\n      throw new Error(`<ProductProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`);\n    }\n    return flattenConnection(selectedVariant.sellingPlanAllocations).find(allocation => {\n      var _a2;\n      return ((_a2 = allocation == null ? void 0 : allocation.sellingPlan) == null ? void 0 : _a2.id) === selectedSellingPlan.id;\n    });\n  }, [selectedVariant, selectedSellingPlan]);\n  const value = useMemo(() => ({\n    product,\n    variants,\n    variantsConnection: product.variants,\n    options,\n    selectedVariant,\n    setSelectedVariant,\n    selectedOptions,\n    setSelectedOption,\n    setSelectedOptions,\n    isOptionInStock,\n    selectedSellingPlan,\n    setSelectedSellingPlan,\n    selectedSellingPlanAllocation,\n    sellingPlanGroups,\n    sellingPlanGroupsConnection: product.sellingPlanGroups\n  }), [product, isOptionInStock, options, selectedOptions, selectedSellingPlan, selectedSellingPlanAllocation, selectedVariant, sellingPlanGroups, setSelectedOption, variants]);\n  return /* @__PURE__ */jsx(ProductOptionsContext.Provider, {\n    value,\n    children\n  });\n}\nfunction useProduct() {\n  const context = useContext(ProductOptionsContext);\n  if (!context) {\n    throw new Error(`'useProduct' must be a child of <ProductProvider />`);\n  }\n  return context;\n}\nfunction getSelectedVariant(variants, choices) {\n  var _a, _b;\n  if (!variants.length || ((_b = (_a = variants == null ? void 0 : variants[0]) == null ? void 0 : _a.selectedOptions) == null ? void 0 : _b.length) !== Object.keys(choices).length) {\n    return;\n  }\n  return variants == null ? void 0 : variants.find(variant => {\n    return Object.entries(choices).every(_ref2 => {\n      let [name, value] = _ref2;\n      var _a2;\n      return (_a2 = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a2.some(option => (option == null ? void 0 : option.name) === name && (option == null ? void 0 : option.value) === value);\n    });\n  });\n}\nfunction getOptions(variants) {\n  const map = variants.reduce((memo, variant) => {\n    var _a;\n    if (!variant.selectedOptions) {\n      throw new Error(`'getOptions' requires 'variant.selectedOptions'`);\n    }\n    (_a = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a.forEach(opt => {\n      memo[(opt == null ? void 0 : opt.name) ?? \"\"] = memo[(opt == null ? void 0 : opt.name) ?? \"\"] || /* @__PURE__ */new Set();\n      memo[(opt == null ? void 0 : opt.name) ?? \"\"].add((opt == null ? void 0 : opt.value) ?? \"\");\n    });\n    return memo;\n  }, {});\n  return Object.keys(map).map(option => {\n    return {\n      name: option,\n      values: Array.from(map[option])\n    };\n  });\n}\nfunction getVariantBasedOnIdProp(explicitVariantId, variants) {\n  if (explicitVariantId) {\n    const foundVariant = variants.find(variant => (variant == null ? void 0 : variant.id) === explicitVariantId);\n    if (!foundVariant) {\n      console.warn(`<ProductProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`);\n    }\n    return foundVariant;\n  }\n  if (explicitVariantId === null) {\n    return null;\n  }\n  if (explicitVariantId === void 0) {\n    return variants.find(variant => variant == null ? void 0 : variant.availableForSale) || variants[0];\n  }\n}\nfunction getSelectedOptions(selectedVariant) {\n  return (selectedVariant == null ? void 0 : selectedVariant.selectedOptions) ? selectedVariant.selectedOptions.reduce((memo, optionSet) => {\n    memo[(optionSet == null ? void 0 : optionSet.name) ?? \"\"] = (optionSet == null ? void 0 : optionSet.value) ?? \"\";\n    return memo;\n  }, {}) : {};\n}\nfunction isProductVariantArray(maybeVariantArray) {\n  if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {\n    return false;\n  }\n  return true;\n}\nexport { ProductProvider, useProduct };","map":{"version":3,"names":["ProductOptionsContext","createContext","ProductProvider","_ref","children","data","product","initialVariantId","explicitVariantId","variants","useMemo","flattenConnection","isProductVariantArray","Error","options","getOptions","selectedVariant","setSelectedVariant","useState","getVariantBasedOnIdProp","selectedOptions","setSelectedOptions","getSelectedOptions","useEffect","newSelectedVariant","setSelectedOption","useCallback","name","value2","selectedOptions2","opts","getSelectedVariant","isOptionInStock","option","proposedVariant","availableForSale","sellingPlanGroups","map","sellingPlanGroup","sellingPlans","selectedSellingPlan","setSelectedSellingPlan","selectedSellingPlanAllocation","_a","sellingPlanAllocations","nodes","_b","edges","find","allocation","_a2","sellingPlan","id","value","variantsConnection","sellingPlanGroupsConnection","jsx","Provider","useProduct","context","useContext","choices","length","Object","keys","variant","entries","every","_ref2","some","reduce","memo","forEach","opt","Set","add","values","Array","from","foundVariant","console","warn","optionSet","maybeVariantArray","isArray"],"sources":["/home/martin/node_modules/.pnpm/@shopify+hydrogen-react@2023.4.0_react-dom@18.2.0_react@18.2.0_typescript@5.0.4/node_modules/@shopify/hydrogen-react/src/ProductProvider.tsx"],"sourcesContent":["import {\n  useMemo,\n  useState,\n  useEffect,\n  useCallback,\n  createContext,\n  useContext,\n} from 'react';\nimport type {\n  SelectedOption as SelectedOptionType,\n  SellingPlan,\n  SellingPlanAllocation,\n  Product,\n  ProductVariant as ProductVariantType,\n  ProductVariantConnection,\n  SellingPlan as SellingPlanType,\n  SellingPlanAllocation as SellingPlanAllocationType,\n  SellingPlanGroup as SellingPlanGroupType,\n  SellingPlanGroupConnection,\n} from './storefront-api-types.js';\nimport type {PartialDeep} from 'type-fest';\nimport {flattenConnection} from './flatten-connection.js';\n\nconst ProductOptionsContext = createContext<ProductHookValue | null>(null);\n\ntype InitialVariantId = ProductVariantType['id'] | null;\n\ninterface ProductProviderProps {\n  /** A Storefront API [Product object](https://shopify.dev/api/storefront/reference/products/product). */\n  data: PartialDeep<Product, {recurseIntoArrays: true}>;\n  /** A `ReactNode` element. */\n  children: React.ReactNode;\n  /**\n   * The initially selected variant.\n   * The following logic applies to `initialVariantId`:\n   * 1. If `initialVariantId` is provided, then it's used even if it's out of stock.\n   * 2. If `initialVariantId` is provided but is `null`, then no variant is used.\n   * 3. If nothing is passed to `initialVariantId` then the first available / in-stock variant is used.\n   * 4. If nothing is passed to `initialVariantId` and no variants are in stock, then the first variant is used.\n   */\n  initialVariantId?: InitialVariantId;\n}\n\n/**\n * `<ProductProvider />` is a context provider that enables use of the `useProduct()` hook.\n *\n * It helps manage selected options and variants for a product.\n */\nexport function ProductProvider({\n  children,\n  data: product,\n  initialVariantId: explicitVariantId,\n}: ProductProviderProps): JSX.Element {\n  // The flattened variants\n  const variants = useMemo(\n    () => flattenConnection(product.variants ?? {}),\n    [product.variants],\n  );\n\n  if (!isProductVariantArray(variants)) {\n    throw new Error(\n      `<ProductProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`,\n    );\n  }\n\n  // All the options available for a product, based on all the variants\n  const options = useMemo(() => getOptions(variants), [variants]);\n\n  /**\n   * Track the selectedVariant within the provider.\n   */\n  const [selectedVariant, setSelectedVariant] = useState<\n    | PartialDeep<ProductVariantType, {recurseIntoArrays: true}>\n    | undefined\n    | null\n  >(() => getVariantBasedOnIdProp(explicitVariantId, variants));\n\n  /**\n   * Track the selectedOptions within the provider. If a `initialVariantId`\n   * is passed, use that to select initial options.\n   */\n  const [selectedOptions, setSelectedOptions] = useState<SelectedOptions>(() =>\n    getSelectedOptions(selectedVariant),\n  );\n\n  /**\n   * When the initialVariantId changes, we need to make sure we\n   * update the selected variant and selected options. If not,\n   * then the selected variant and options will reference incorrect\n   * values.\n   */\n  useEffect(() => {\n    const newSelectedVariant = getVariantBasedOnIdProp(\n      explicitVariantId,\n      variants,\n    );\n    setSelectedVariant(newSelectedVariant);\n    setSelectedOptions(getSelectedOptions(newSelectedVariant));\n  }, [explicitVariantId, variants]);\n\n  /**\n   * Allow the developer to select an option.\n   */\n  const setSelectedOption = useCallback(\n    (name: string, value: string) => {\n      setSelectedOptions((selectedOptions) => {\n        const opts = {...selectedOptions, [name]: value};\n        setSelectedVariant(getSelectedVariant(variants, opts));\n        return opts;\n      });\n    },\n    [setSelectedOptions, variants],\n  );\n\n  const isOptionInStock = useCallback(\n    (option: string, value: string) => {\n      const proposedVariant = getSelectedVariant(variants, {\n        ...selectedOptions,\n        ...{[option]: value},\n      });\n\n      return proposedVariant?.availableForSale ?? true;\n    },\n    [selectedOptions, variants],\n  );\n\n  const sellingPlanGroups = useMemo(\n    () =>\n      flattenConnection(product.sellingPlanGroups ?? {}).map(\n        (sellingPlanGroup) => ({\n          ...sellingPlanGroup,\n          sellingPlans: flattenConnection(sellingPlanGroup?.sellingPlans ?? {}),\n        }),\n      ),\n    [product.sellingPlanGroups],\n  );\n\n  /**\n   * Track the selectedSellingPlan within the hook. If `initialSellingPlanId`\n   * is passed, use that as an initial value. Look it up from the `selectedVariant`, since\n   * that is also a requirement.\n   */\n  const [selectedSellingPlan, setSelectedSellingPlan] = useState<\n    PartialDeep<SellingPlan, {recurseIntoArrays: true}> | undefined\n  >(undefined);\n\n  const selectedSellingPlanAllocation = useMemo<\n    PartialDeep<SellingPlanAllocation, {recurseIntoArrays: true}> | undefined\n  >(() => {\n    if (!selectedVariant || !selectedSellingPlan) {\n      return;\n    }\n\n    if (\n      !selectedVariant.sellingPlanAllocations?.nodes &&\n      !selectedVariant.sellingPlanAllocations?.edges\n    ) {\n      throw new Error(\n        `<ProductProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`,\n      );\n    }\n\n    return flattenConnection(selectedVariant.sellingPlanAllocations).find(\n      (allocation) => allocation?.sellingPlan?.id === selectedSellingPlan.id,\n    );\n  }, [selectedVariant, selectedSellingPlan]);\n\n  const value = useMemo<ProductHookValue>(\n    () => ({\n      product,\n      variants,\n      variantsConnection: product.variants,\n      options,\n      selectedVariant,\n      setSelectedVariant,\n      selectedOptions,\n      setSelectedOption,\n      setSelectedOptions,\n      isOptionInStock,\n      selectedSellingPlan,\n      setSelectedSellingPlan,\n      selectedSellingPlanAllocation,\n      sellingPlanGroups,\n      sellingPlanGroupsConnection: product.sellingPlanGroups,\n    }),\n    [\n      product,\n      isOptionInStock,\n      options,\n      selectedOptions,\n      selectedSellingPlan,\n      selectedSellingPlanAllocation,\n      selectedVariant,\n      sellingPlanGroups,\n      setSelectedOption,\n      variants,\n    ],\n  );\n\n  return (\n    <ProductOptionsContext.Provider value={value}>\n      {children}\n    </ProductOptionsContext.Provider>\n  );\n}\n\n/**\n * Provides access to the context value provided by `<ProductProvider />`. Must be a descendent of `<ProductProvider />`.\n */\nexport function useProduct(): ProductHookValue {\n  const context = useContext(ProductOptionsContext);\n\n  if (!context) {\n    throw new Error(`'useProduct' must be a child of <ProductProvider />`);\n  }\n\n  return context;\n}\n\nfunction getSelectedVariant(\n  variants: PartialDeep<ProductVariantType, {recurseIntoArrays: true}>[],\n  choices: SelectedOptions,\n): PartialDeep<ProductVariantType, {recurseIntoArrays: true}> | undefined {\n  /**\n   * Ensure the user has selected all the required options, not just some.\n   */\n  if (\n    !variants.length ||\n    variants?.[0]?.selectedOptions?.length !== Object.keys(choices).length\n  ) {\n    return;\n  }\n\n  return variants?.find((variant) => {\n    return Object.entries(choices).every(([name, value]) => {\n      return variant?.selectedOptions?.some(\n        (option) => option?.name === name && option?.value === value,\n      );\n    });\n  });\n}\n\nfunction getOptions(\n  variants: PartialDeep<ProductVariantType, {recurseIntoArrays: true}>[],\n): OptionWithValues[] {\n  const map = variants.reduce((memo, variant) => {\n    if (!variant.selectedOptions) {\n      throw new Error(`'getOptions' requires 'variant.selectedOptions'`);\n    }\n    variant?.selectedOptions?.forEach((opt) => {\n      memo[opt?.name ?? ''] = memo[opt?.name ?? ''] || new Set();\n      memo[opt?.name ?? ''].add(opt?.value ?? '');\n    });\n\n    return memo;\n  }, {} as Record<string, Set<string>>);\n\n  return Object.keys(map).map((option) => {\n    return {\n      name: option,\n      values: Array.from(map[option]),\n    };\n  });\n}\n\nfunction getVariantBasedOnIdProp(\n  explicitVariantId: InitialVariantId | undefined,\n  variants: Array<\n    PartialDeep<ProductVariantType, {recurseIntoArrays: true}> | undefined\n  >,\n):\n  | PartialDeep<ProductVariantType, {recurseIntoArrays: true}>\n  | undefined\n  | null {\n  // get the initial variant based on the logic outlined in the comments for 'initialVariantId' above\n  // * 1. If `initialVariantId` is provided, then it's used even if it's out of stock.\n  if (explicitVariantId) {\n    const foundVariant = variants.find(\n      (variant) => variant?.id === explicitVariantId,\n    );\n    if (!foundVariant) {\n      console.warn(\n        `<ProductProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`,\n      );\n    }\n    return foundVariant;\n  }\n  // * 2. If `initialVariantId` is provided but is `null`, then no variant is used.\n  if (explicitVariantId === null) {\n    return null;\n  }\n  // * 3. If nothing is passed to `initialVariantId` then the first available / in-stock variant is used.\n  // * 4. If nothing is passed to `initialVariantId` and no variants are in stock, then the first variant is used.\n  if (explicitVariantId === undefined) {\n    return variants.find((variant) => variant?.availableForSale) || variants[0];\n  }\n}\n\nfunction getSelectedOptions(\n  selectedVariant:\n    | PartialDeep<ProductVariantType, {recurseIntoArrays: true}>\n    | undefined\n    | null,\n): SelectedOptions {\n  return selectedVariant?.selectedOptions\n    ? selectedVariant.selectedOptions.reduce<SelectedOptions>(\n        (memo, optionSet) => {\n          memo[optionSet?.name ?? ''] = optionSet?.value ?? '';\n          return memo;\n        },\n        {},\n      )\n    : {};\n}\n\nfunction isProductVariantArray(\n  maybeVariantArray:\n    | (PartialDeep<ProductVariantType, {recurseIntoArrays: true}> | undefined)[]\n    | undefined,\n): maybeVariantArray is PartialDeep<\n  ProductVariantType,\n  {recurseIntoArrays: true}\n>[] {\n  if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface OptionWithValues {\n  name: SelectedOptionType['name'];\n  values: SelectedOptionType['value'][];\n}\n\ntype UseProductObjects = {\n  /** The raw product from the Storefront API */\n  product: Product;\n  /** An array of the variant `nodes` from the `VariantConnection`. */\n  variants: ProductVariantType[];\n  variantsConnection?: ProductVariantConnection;\n  /** An array of the product's options and values. */\n  options: OptionWithValues[];\n  /** The selected variant. */\n  selectedVariant?: ProductVariantType | null;\n  selectedOptions: SelectedOptions;\n  /** The selected selling plan. */\n  selectedSellingPlan?: SellingPlanType;\n  /** The selected selling plan allocation. */\n  selectedSellingPlanAllocation?: SellingPlanAllocationType;\n  /** The selling plan groups. */\n  sellingPlanGroups?: (Omit<SellingPlanGroupType, 'sellingPlans'> & {\n    sellingPlans: SellingPlanType[];\n  })[];\n  sellingPlanGroupsConnection?: SellingPlanGroupConnection;\n};\n\ntype UseProductFunctions = {\n  /** A callback to set the selected variant to the variant passed as an argument. */\n  setSelectedVariant: (\n    variant: PartialDeep<ProductVariantType, {recurseIntoArrays: true}> | null,\n  ) => void;\n  /** A callback to set the selected option. */\n  setSelectedOption: (\n    name: SelectedOptionType['name'],\n    value: SelectedOptionType['value'],\n  ) => void;\n  /** A callback to set multiple selected options at once. */\n  setSelectedOptions: (options: SelectedOptions) => void;\n  /** A callback to set the selected selling plan to the one passed as an argument. */\n  setSelectedSellingPlan: (\n    sellingPlan: PartialDeep<SellingPlanType, {recurseIntoArrays: true}>,\n  ) => void;\n  /** A callback that returns a boolean indicating if the option is in stock. */\n  isOptionInStock: (\n    name: SelectedOptionType['name'],\n    value: SelectedOptionType['value'],\n  ) => boolean;\n};\n\ntype ProductHookValue = PartialDeep<\n  UseProductObjects,\n  {recurseIntoArrays: true}\n> &\n  UseProductFunctions;\n\nexport type SelectedOptions = {\n  [key: string]: string;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}